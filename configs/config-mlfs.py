#!/bin/bash

##################################################################################
# Pipeline folder structures
##################################################################################
# - AFL++      : AFL repository (should contain afl-gcc and afl-fuzz)
# - pipeline   : pipeline source codes (in Python 3)
# - singularity: singularity image files
# - config.py  : default configuration file
# - run.py     : pipeline main for a single run of fuzzing
# - run_list.py: pipeline main for multiple run of fuzzing
# - launcher.sh: sbatch launcher for a single run of fuzzing (with singularity)
# - parallel.sh: sbatch parallel launcher for multiple mutant fuzzing (with singularity)
# - [exp_base] : experiment base path
#       * src.tar    : original source code of SUT (should not be compressed)
#       * repos      : code repository folder that the src.tar will be extracted
#       * mutants    : a folder containing mutants that generated by a tool (case study)
#       * list_mutant: a file containing list of target mutants that we want to fuzz
#       * test_cases_filter.csv: a file containing test case filters for each function (????)
#       * outputs or [EXP_NAME]:
#            + 1-func-drivers: test drivers for a function
#            + 2-func-inputs: seed inputs for a function
#            + 3-mutant-funcs: functions that are extracted from the mutants (only mutated functions)
#            + 4-mutant-bins: compiled results for each mutant
#            + 5-fuzzing-<EXP_TAG_NAME>: will be stored results of fuzzing
#            + 6-verification-<EXP_TAG_NAME>: will be stored results of 'verify' phase
#            + log-<EXP_TAG_NAME>: will be stored results of fuzzing


##################################################################################
# Paths for the experiment directory
#   - the relative path in this section will be under EXP_BASE
#   - if you do not want to set the path outside of EXP_BASE, then use absolute path
##################################################################################
EXP_BASE ='./case_studies/MLFS'

# code repository in the EXP_BASE
REPO_FILE   = './src.tar'    # tar archive file that contains source code of SUT
REPO_PATH   = './repos'       # a folder that will be the repo file will be extracted
# Actual repository path will be changed depends on options
# e.g., without parallel: <REPO_PATH>
#       with parallel:    <HPC_WORK_PATH>/<REPO_PATH>/.../<mutant_name>

# folder name in the EXP_BASE that contains mutants generated by a case study tool
MUTANTS_FILE  = './mutants.tar'

# The root of the main output folder
# When you do multiple experiments at the same time, please provide different name for each experiment
# This variable is used as OUTPUT_PATH, which is concatenated EXP_BASE + '/'+ EXP_NAME
EXP_NAME     = 'outputs' # output folder name

# Sub-Output folder for the fuzzing results
# If you do an experiment using the same executable SUTs, please specify this value.
EXP_TAG_NAME = ''

# The names below are the outputs that will be generated by this pipeline
# These names will be the folders in the OUTPUT_PATH
FUNC_DRIVER_NAME    = '1-func-drivers'      # a folder for the test drivers for a function
FUNC_INPUT_NAME     = '2-func-inputs'       # a folder for the inputs of AFL for each function
MUTANT_FUNC_NAME    = '3-mutant-funcs'      # a folder for mutated functions extracted from mutants
MUTANT_BIN_NAME     = '4-mutant-bins'       # a folder for the object file of mutation testing
FUZZING_OUTPUT_NAME = '5-fuzzing'           # a folder for the outputs of AFL for each object file (and each run)
VERIFY_OUTPUT_NAME  = '6-verification'      # a folder for the outputs of 'verify' phase for each mutant (and each run)


##################################################################################
# experiment parameters
##################################################################################
# the maximum execution time of fuzzing
FUZZING_TIMEOUT = 10

# prefix when this pipeline extracts mutated function from the corresponding source code
MUTANT_FUNC_PREFIX = 'mut'

# compress when the fuzzing is finished
COMPRESS_RESULT = True


##################################################################################
# parameters for fuzzing tool
##################################################################################
FUZZER_FILEPATH   = './AFL++/afl-fuzz'
COMPILER_FILEPATH = './AFL++/afl-gcc'
CPP_COMPILER_FILEPATH = './AFL++/afl-g++'
FUZZER_ENVS = {
    "AFL_NO_AFFINITY":1,
    "AFL_NO_UI":1,
    "AFL_SKIP_CPUFREQ":1,
    "AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES":1,
    "AFL_BENCH_UNTIL_CRASH":1,
}

# timeout for each test case execution in AFL (millisecond)
# The large number can reduce the fuzzing performance significantly
TEST_EXEC_TIMEOUT = 1000
# FUZZER_ENVS = None

FUZZER_PRINT_LOG_DETAILS = False
FUZZER_PRINT_INPUTS = False
FUZZER_PRINT_CRASHES = True  # Exclusive with FUZZER_PRINT_INPUTS


##################################################################################
# Template configurations: template paths and array settings
##################################################################################
# Directory path in which the template files are located
TEMPLATE_ROOT_DIR           = "./pipeline/templates"

# Template entry filename (relative path based on the TEMPLATE_ROOT_DIR)
TEMPLATE_FUZZING_DRIVER         = "driver_template.c.jinja2"
TEMPLATE_PRESENTER_DRIVER       = "presenter_template.c.jinja2"
TEMPLATE_TESTCASE_DRIVER        = "testcase_template.c.jinja2"
TEMPLATE_FALSE_POSITIVE_DRIVER  = "false_template.c.jinja2"
TEMPLATE_DEPENDENCY_DRIVER      = "dependency_template.c.jinja2"

# Configuration options for test drivers for a function
TEMPLATE_CONFIG = {
    # Exclude headers not in using with the template compile flags
    # It is automatically removed using libclang.
    # But, It can be an issue when the source code contains "." or ".." in the include path
    # then, turn off the AUTO_EXCLUDE_HEADERS and use EXCLUDE_HEADERS list.
    "AUTO_EXCLUDE_HEADERS": True,
    "EXCLUDE_HEADERS": [],

    # If the incomplete arrays (e.g., int[]) do not have corresponding definition in PARAMETER_FORMAT,
    #   they are going to use this DEFAULT_ARRAY_SIZE.
    "DEFAULT_ARRAY_SIZE": 100,

    # This field is used for customizing pointer parameters for generating test drivers and input data.
    # Since MOTIF cannot distinguish whether pointer parameters expects to get an array or a single variable,
    # You need to give a guide using this field.
    # If you want to treat a pointer parameter as an array, specify its size, data type, and format as the below:
    # Example:
    #     {"function": "gs_clock_from_string", "parameter": "str", "size": 21, "type": "char", "format": "ISO8601"},
    # - "function" and "parameter": (necessary) used to target a specific parameter of a function
    # - "size":   (necessary) used to specify the array size of the parameter
    # - "type":   (optional) used to specify the data type of the parameter (if the actual data type is different)
    # - "format": (optional) used to specify the data format (its value should be defined in the 'INPUT_VALUES_MAP' field.)
    # - "file":   (optional) if you need, you can specify the target file name
    "PARAMETER_FORMAT":[
        {"file":None, "function": "__kernel_rem_pio2",   "parameter": "x", "size": 20, "format": None},
        {"file":None, "function": "__kernel_rem_pio2",   "parameter": "y", "size": 2,  "format": None},
        {"file":None, "function": "__kernel_rem_pio2f",  "parameter": "x", "size": 20, "format": None},
        {"file":None, "function": "__kernel_rem_pio2f",  "parameter": "y", "size": 2,  "format": None},
        {"file":None, "function": "__ieee754_rem_pio2",  "parameter": "y", "size": 2,  "format": None},
        {"file":None, "function": "__ieee754_rem_pio2f", "parameter": "y", "size": 2,  "format": None},
    ],

    # This field is used for dealing with a structure data type containing pointer fields.
    # Because the pointer field can vary the size of the structure.
    # We define an array and assign it to the field (pointer) in the structure. (the array will be filled from the input data)
    # Please specify parameters and a list of fields that you want to assign array (see the example dictionary below)
    #  - "user_fields": Specifying a list of fields with its data type, size, and so on.
    #  - "*_statements" strings are used for initializing the struct parameter.
    #     + {param} will be replaced with the name of the struct variable,
    #     + {field.1} will be replaced with the field name of the first item in the "array_fields"
    #     + {size.1} will be replaced with the field size of the first item in the "array_fields"
    'STRUCT_FIELD_BUFFER':{
        # "<name of struct>": {
        #      "user_fields" [
        #           {"name": "<name of field>", "type": "<data type of the field>", "size": <size of the array>},
        #            "string": <1 or 0>, 'print_format': "<format string for printf>"
        #      ],
        #      "before_statements":"<codes before copy data from input file to the structure variable>",
        #      "after_statements":"<codes after copy data from input file to the structure variable>",}
    },

    # This field is used for generating input values according to the data type of parameters
    # User-defined format, such as ISO8601, enable MOTIF to generate a special format of an input value
    #     To apply the user-defined format, you need to set the format name in the PARAMETER_FORMAT
    'INPUT_VALUES_MAP': {
        "default":  {"N":-1, "Z":0, "P":1},
        "_Bool":    {"N": False, "Z": True, "P": True},
        "float":    {"N":-3230283776.0, "Z":0.0, "P":1072693248.0},
        "double":   {"N":-13826050856027422720.0, "Z":0.0, "P":4602891378046628864.0},
        "char":     {"N":b'\xFF', "Z":b'\x00', "P":b'\x41'},
        "byte":     {"N":b'\xFF', "Z":b'\x00', "P":b'\x41'},
        # "ISO8601":  {"N":"2145916800.999999999", "Z":"1970-01-01T00:00:00Z", "P":"2038-01-01T00:00:00Z"},
    },

    # Initialization steps for each source file (not support for function at this point)
    "INITIALIZE": {
        # "<source file>":[<list of commands>],
    },

    # For mutants that should not include "extern" declaration
    "NO_EXTERNS": [
        # {"file": "<Source file path>", "function":"<function name>"},
    ]
}


##################################################################################
# Subject compilation parameters (These parameters need to be specified for each subject)
# ******Important notice
#        - The relative path in this section will be located in the REPO_PATH, please be careful.
##################################################################################
# Compilation flags
#   - Used for generating templates and compiling test driver
#   - Used for compiling SUT if the COMPILE_SUT_CMDS is None
#   - Compile option '-c' should not be included in this flag (it is included internally when it is required)
#   - If you wnat to turn off warnings, please add `-w` option
SUT_COMPILE_FLAGS = "-Wall -std=gnu99 -pedantic -Wextra -frounding-math -fsignaling-nans -g -O2 -fno-builtin"

# Include files that are required to compile
#   - Used for generating templates and compiling test driver
#   - Used for compiling SUT if the COMPILE_SUT_CMDS is None
#   - Default relative path(".") is the REPO_PATH
INCLUDES = ["./include", "./libm/common", "./libm/math", "./libm/mlfs"]

# A list of commands to compile:
#   - When the SUT requires to build them with a build suite such as make and waf, specify the commands list
#   - The commands will be executed in the order
#   - COMPILER_FILEPATH will be provided as shell environment by exporting CC, AS, CXX
#   - If this option is None, the pipeline will compile each source file of SUT
#                             using SUT_COMPILE_FLAGS, INCLUDES, COMPILE_OUTPUT and COMPILE_SUT_FILES
COMPILE_SUT_CMDS = ["make clean", "make"]

# A list of source files to compile together with target source code of mutant:
#   - This list is used if COMPILE_SUT_CMDS is None
#   - Default relative path(".") is the REPO_PATH
#   - `*`: to specify multiple files e.g., *.o
#   - `**`: to search files recursively e.g., ./**/*.o: includes all *.o files in ./ recursively
COMPILE_SUT_FILES = None   #["./**/*.c"]

# Compile output path
#   - Used this option if COMPILE_SUT_CMDS is None
#   - The files specified in COMPILE_SUT_FILES will be compiled in this directory
#   - The result files (objectives) will have same directory structures.
#   - Default relative path(".") is the REPO_PATH
COMPILE_OUTPUT = None

# Filepaths of the compiled SUT objects
#   - Please provide a list of files to be linked when test driver is compiled
#   - `*`: to specify multiple files e.g., *.o
#   - `**`: to search files recursively e.g., ./_build/**/*.o: includes all *.o files in ./_build recursively
COMPILED_OBJECTS = ["./build-x86_64-linux-gnu/bin/libmlfs.a"]

# The compilation options for the linker
#   - When compiling test driver, the pipeline links the COMPILED_OBJECTS.
#   - Addition to SUT_COMPILE_FLAGS, specify compile options if it is needed
LINKER_FLAGS = ""


##################################################################################
# HPC parameters (Use this parameter when you work on HPC)
##################################################################################
# This parameter makes this pipeline run on singularity by submitting a job to SLURM (job manager on HPC)
HPC = False

# This parameter makes this pipeline run in parallel
# When it is True, HPC_WORK_PATH will be used for code compling and fuzzing
HPC_PARALLEL = False

# When you generate a lot of temporary files at the same time,
# it will significantly reduce the performance of HPC.
# Since a local storage (SSD) is mounted to the temporary folder(/tmp) in each work node,
# it is recommended to use the folder for the temporary files.
# As we produce a lot of files during compilation of SUT, we need to use the temporary folder.
# This is also good for the performance of this pipeline.
HPC_WORK_PATH          = '/tmp/MOTIF/MLFS'


# HPC sbatch log settings
HPC_LOG_PREFIX = "logs"
LOG_FILE_NAME = "%j-%x.out"
LIST_JOBID_PATH = "__submitted_jobs__"

# singularity image file that the pipeline will be executed
SINGULARITY_FILE = "containers/motif_default.sif"


##################################################################################
# Parallel configurations
##################################################################################
# Control variables of the number of tasks in one parallel job
# The following two variables are the same, total execution time will be the same to the one task's timeout
N_TASKS_PER_JOB = 200         # How many commands will be executed in one parallel job
N_PARALLELS_PER_JOB = 100     # How many commands will be executed simultaneously

# REPORT_EMAIL = None
REPORT_EMAIL = "jaekwon.lee@uni.lu"
SBATCH_PARAMETERS = ""


##################################################################################
# The pipeline and program entry points
##################################################################################
PYTHON_CMD="python3"
# PYTHON_CMD="./venv/bin/python3"
SINGLE_RUN_FILE = "./run.py"
MULTI_RUN_FILE = "./run_list.py"
SLURM_PARALLEL_EXECUTOR="./scripts/HPC/parallel.sh"
SLURM_SINGLE_EXECUTOR="./scripts/HPC/launcher.sh"

